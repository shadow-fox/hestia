pub mod equity;
pub mod models;

use csv::{ReaderBuilder};
use diesel::Queryable;
use reqwest::Client;
use serde::Deserialize;

#[derive(Queryable, Debug, PartialEq, Eq, Clone, Deserialize)]
//#[serde(rename_all = "UPPERCASE")]
// EQUITY_L.csv 
// SYMBOL,NAME OF COMPANY, SERIES, DATE OF LISTING, PAID UP VALUE, MARKET LOT, ISIN NUMBER, FACE VALUE
// SME_EQUITY_L.csv
// Yet to implement
pub struct Scrip {
    #[serde(alias = "SYMBOL")]
    pub symbol: String,
    #[serde(alias = "NAME OF COMPANY")]
    pub name: String,
    #[serde(alias = " SERIES")]
    pub series: String,
    #[serde(alias = " DATE OF LISTING")]
    pub date_listing: String,
    #[serde(alias = " PAID UP VALUE")]
    pub paid_up_value: i32,
    #[serde(alias = " MARKET LOT")]
    pub market_lot: i32,
    #[serde(alias = " ISIN NUMBER")]
    pub isin_number: String ,
    #[serde(alias = " FACE VALUE")]
    pub face_value: i32,
}

// 1. get_all_symbols
pub async fn get_all_symbols () -> Vec<Scrip> {
    let client = reqwest::Client::default();
    parse_all_segment_list(&client).await.unwrap()
}

// Get data from archives for all the segments EQ, SME, DR etc.
pub async fn parse_all_segment_list(client: &Client) -> Result<Vec<Scrip>, String> {
    //GET https://archives.nseindia.com/content/equities/EQUITY_L.csv
    //GET https://archives.nseindia.com/emerge/corporates/content/SME_EQUITY_L.csv
    let url = "https://archives.nseindia.com/content/equities/EQUITY_L.csv";
    let res = client
        .get(url)
        .send()
        .await
        .or(Err(format!("Failed to GET from '{}'", &url)))?;
    //println!("{:?}", &res.headers());
    let content = res.text().await;
    //println!("{:?}", content);
    match content {
        Ok(res) => {
            let scrip_all = parse_equity_csv(res);
            match scrip_all {
                Ok(scrip_vec) => Ok(scrip_vec),
                Err(err) => Err("Error occured {}".to_string())
            }
        },
        Err(err) => Err("Error occured {}".to_string())
    }   
}

// Parse the csv for each segments.
// Segment data is different need match on the segment we are parsing.
pub fn parse_equity_csv (data: String) -> Result<Vec<Scrip>, csv::Error> {
    //println!("DAta {}", data);
    let mut scrip_all:Vec<Scrip> = Vec::default();
    
    let mut reader_data = ReaderBuilder::new().has_headers(true).from_reader(data.as_bytes());
    for result in reader_data.deserialize() {
        let record: Scrip = result?;
        //println!("{:?}", record);
        scrip_all.push(record.clone())
    }
    Ok(scrip_all)
}

//2. Info About Scrip

pub fn parse_equity() -> Result<>


















//3. PreOpen Data 
// pub async fn get_pre_open_market (client: &Client) -> Result<Vec<Scrip>, String> {
//     // PreOpen Market: Get https://www.nseindia.com/api/market-data-pre-open?key=ALL&csv=true
//        let url = "https://www.nseindia.com/api/market-data-pre-open?key=ALL&csv=true";
//        let res = client
//            .get(url)
//            .send()
//            .await
//            .or(Err(format!("Failed to GET from '{}'", &url)))?;
//        println!("{:?}", &res.headers());
//        let content = res.text().await;
//        //println!("{:?}", content);
//        match content {
//            Ok(res) => {
//                let scrip_all = parse_pre_open_market_csv(res);
//                match scrip_all {
//                    Ok(scrip_vec) => Ok(scrip_vec),
//                    Err(err) => Err("Error occured {}".to_string())
//                }
//            },
//            Err(err) => Err("Error occured {}".to_string())
//        }    
//    }
   
//    pub fn parse_pre_open_market_csv(data: String) -> () {
       
//    }
//4. Historical Data
//5. News, Etc.

